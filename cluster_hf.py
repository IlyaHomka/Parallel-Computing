# -*- coding: utf-8 -*-
"""Cluster Nature_Heat_Rectification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RlhH3w0pfXsTSoADuG8BzPrjNL2L_Ob_
"""

# Commented out IPython magic to ensure Python compatibility.
import math 
import cmath as cth
import sympy as sp
from sympy import *
pi = math.pi
import matplotlib.pyplot as plt
import numpy as np
import sys
# Suppress warnings
import warnings
warnings.filterwarnings('ignore'),
# %matplotlib inline
import matplotlib
import scipy
import scipy.integrate as integrate
#from sympy import symbols, integrate
import scipy.special as special

from numpy import inf

#Physical constants
hbar = 6.626 /(2*pi)*1e-34  #Planck constant J.s
e = 1.6*1e-19               #elementary charge C
me = 9.31*1e-31             #electron mass kg
m = 2 * me                  #Cooper paris charge C            
q = 2 * e                   #Cooper paris mass kg
kB=1.38*1e-23               #Boltzmann constant J.K^-1

# Circuit parameters
GT = 1./1000 # Ohm^(-1)
L = 1*1e-9 # Hn
C = 100*1e-15 # F
R = 1e3 # Ohm
Ph0 = 6.626 /q*1e-34

# Voltage 
t = np.linspace(0,1,500) # 100
V0 = 1e-6# V      
r = np.linspace(0,1,500)

Omega= 1.5 * pi * 1e9 
V = V0 * np.sin(Omega*t)
phi = 2*e*V0/(hbar*Omega) * (1. - np.cos(Omega*t))

# Junction characteristics
TcL = 1.4                                    # K
TcR = 0.75*TcL                               # K 
deltacL = 1.764*kB*TcL                       # J   
deltacR = 1.764*kB*TcR                       # J 
TL = r*TcL #r*TcL# 0.77                      # K
TR = 0.01*TcL                                # K                                
deltac = 1.764*kB*TcL                        # J 
GammaL = 1e-4*deltacL                        # Dynes parameter 
GammaR = 1e-4*deltacR                        # Dynes parameter

delta = lambda T, Tc, deltac: deltac*np.tanh(1.74*abs(Tc/T-1)**0.5)
#delta1 = lambda T, Tc, deltac: deltac*np.tanh(b*(a*(Tc/T-1))**0.5)
deltaL = delta(TL, TcL, deltacL)
deltaR = delta(TR, TcR, deltacR) #0.75*deltaL# r*deltaL#

muL = 0*V#*deltac/e                    # J
muR = e*V#*deltac/e                    # J

f = lambda x: 1./(1. + np.exp(x))

# Density of states
N = lambda x, y, t: -(((x+1j*y)/(t**2-(x+1j*y)**2)**0.5).imag)
P = lambda x, y, t: -(((x+1j*y)/(t**2-(x+1j*y)**2)**0.5).real)

# Anomalous Gree function: Imaginary part
def M(x, y, t):
  Z = x+1j*y;  
  return (t/(t**2-Z**2)**0.5).imag#*np.sign(x)
# Anomalous Gree function: Real part
def F(x, y, t):
  Z = x+1j*y;  
  return (t/(t**2-Z**2)**0.5).real#*np.sign(x)

# dimensionless integrands for kinetic integrals
# expressed with reduced variable z = E/eV 
def dQqp(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): 
     return (x-muL/deltac)*N(x-muL/deltac, GammaL/deltac, deltaL/deltac) * np.heaviside(muR,0)* N(x-muR/deltac, GammaR/deltac, deltaR/deltac)*(f((x-muL/deltac)*deltac/(kB*TL))-f((x-muR/deltac)*deltac/(kB*TR)))

# dimensionless integrands for kinetic integrals 
# expressed with reduced variable x=E/deltac
def dQint(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): #np.heaviside(muL,0)*
    return (x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*M(x-muR/deltac, GammaR/deltac, deltaR/deltac)*(f((x-muL/deltac)*deltac/(kB*TL))-f((x-muR/deltac)*deltac/(kB*TR)))

# dimensionless integrands for kinetic integrals
# expressed with reduced variable x=E/deltac
def dQj1(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac):
    return (x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))#+ImF(x-muL/deltac, GammaL/deltac, deltaL/deltac) * ReF(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muR/deltac)*deltac/(2*kB*TR)))
def dQj2(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): #L
    return (x-muL/deltac)*F(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*M(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muR/deltac)*deltac/(2*kB*TR))

def dQ1re(t1, x, y, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac, Omega, V0, hbar,t):
  return scipy.real((x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(y-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))*1j*np.exp(-1j*V0/Omega*(- np.cos(Omega*t)-np.cos(Omega*(t+t1))))*np.exp(-1j/hbar*(x-muL/deltac+y-muR/deltac)*t1))
def dQ1im(x, y, t1, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac, Omega, V0, hbar, t):
  return scipy.imag((x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(y-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))*1j*np.exp(-1j*V0/Omega*(- np.cos(Omega*t)-np.cos(Omega*(t+t1))))*np.exp(-1j/hbar*(x-muL/deltac+y-muR/deltac)*t1))

# Integration
Qqp = np.zeros((np.size(r),np.size(V))) #V t
for i in range(np.size(r)): # delta T -- x; V -- y
  for j in range(np.size(V)): 
   Qqp[i,j] = integrate.quad(dQqp,-5,5,args=(GammaL, GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

datacp = np.column_stack([r, V])
datacpfile_path = "param.txt"
np.savetxt(datacpfile_path , datacp)
datafile_path = "rect.txt"
np.savetxt(datafile_path, Qqp)

r1, V1 = np.loadtxt("param.txt", unpack=True)

Q_qp = np.loadtxt("rect.txt")   #genfrom

# Integration
Qint = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
   Qint[i,j] = integrate.quad(dQint,-5,5,args=(GammaL, GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
Qj1 = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    Qj1[i,j] = integrate.quad(dQj1,-1.05, 1.05,args=(100*GammaL, 100*GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

# Integration
Qj2 = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    Qj2[i,j] = integrate.quad(dQj2,-1.05, 1.05,args=(100*GammaL, 100*GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

Qj = 0.5*(Qj1+Qj2)

deltaL1 = delta(TR, TcL, deltacL)
deltaR1 = delta(TL, TcR, deltacR)

# Integration
QqpR =  np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
   QqpR[i,j] = integrate.quad(dQqp,-5,5,args=(GammaL, GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac, deltaR1[i]/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
QintR = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    QintR[i,j] = integrate.quad(dQint,-5,5,args=(GammaL, GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac, deltaR1[i]/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
Qj1R = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)):  
    Qj1R[i,j] = integrate.quad(dQj1,-1.05,1.05,args=(100*GammaL, 100*GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac,deltaR1[i]/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

# Integration
Qj2R = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)):
    Qj2R[i,j] = integrate.quad(dQj2,-1.05,1.05,args=(100*GammaL, 100*GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac,deltaR1[i]/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

QjR = 0.5*(Qj1R+Qj2R)

QL = Qqp + Qj*np.sin(phi) + Qint*np.cos(phi)
QR = - QqpR + QjR*np.sin(phi) - QintR*np.cos(phi)

# Save data to files
data = np.column_stack([r, V])
datacfile_path = "param.txt"
np.savetxt(datacfile_path , datacp)
dataffile_path = "fwdhf.txt"
np.savetxt(dataffile_path, QL)
databfile_path = "bwdhf.txt"
np.savetxt(databfile_path, QR)
