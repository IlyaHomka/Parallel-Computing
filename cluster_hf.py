# -*- coding: utf-8 -*-
"""Cluster Nature_Heat_Rectification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RlhH3w0pfXsTSoADuG8BzPrjNL2L_Ob_
"""

# ! sudo apt-get install texlive-latex-recommended; 
# ! sudo apt-get install dvipng texlive-latex-extra texlive-fonts-recommended;  
# ! wget http://mirrors.ctan.org/macros/latex/contrib/type1cm.zip; 
# ! unzip type1cm.zip -d /tmp/type1cm; 
# ! cd /tmp/type1cm/type1cm/ && sudo latex type1cm.ins;
# ! sudo mkdir /usr/share/texmf/tex/latex/type1cm; 
# ! sudo cp /tmp/type1cm/type1cm/type1cm.sty /usr/share/texmf/tex/latex/type1cm; 
# ! sudo texhash; 
# !apt install cm-super;

# !pip install latex
# !sudo apt-get install dvipng
# !sudo apt-get install -y texlive texlive-latex-extra texlive-latex-recommended

# Commented out IPython magic to ensure Python compatibility.
import math 
import cmath as cth
import sympy as sp
from sympy import *
pi = math.pi
import matplotlib.pyplot as plt
import numpy as np
import sys
# Suppress warnings
import warnings
warnings.filterwarnings('ignore'),
# %matplotlib inline
import matplotlib
import scipy
import scipy.integrate as integrate
#from sympy import symbols, integrate
import scipy.special as special

from numpy import inf
# from IPython.display import set_matplotlib_formats
# set_matplotlib_formats('png', 'pdf')
# matplotlib.rcParams.update({'font.size': 24, 'text.usetex': True}) #

#Physical constants
hbar = 6.626 /(2*pi)*1e-34  #Planck constant J.s
e = 1.6*1e-19               #elementary charge C
me = 9.31*1e-31             #electron mass kg
m = 2 * me                  #Cooper paris charge C            
q = 2 * e                   #Cooper paris mass kg
kB=1.38*1e-23               #Boltzmann constant J.K^-1

# Circuit parameters
GT = 1./1000 # Ohm^(-1)
L = 1*1e-9 # Hn
C = 100*1e-15 # F
R = 1e3 # Ohm
Ph0 = 6.626 /q*1e-34

# Voltage 
t = np.linspace(0,1,500) # 100
V0 = 1e-6# V      
r = np.linspace(0,1,500)

Omega= 1.5 * pi * 1e9 #1.5
#V = V0 * np.cos(Omega*t)
V = V0 * np.sin(Omega*t)

#omega = 2*e*V/hbar*1e-6
#phi = 2*e*V0/(hbar*Omega) * np.sin(Omega*t)
phi = 2*e*V0/(hbar*Omega) * (1. - np.cos(Omega*t))

# # import matplotlib.ticker as plticker
# fig=plt.figure(figsize=(8, 5))
# # v=np.linspace(-180,180,25)
# # x,y = np.meshgrid(v,v)
# # z = np.add(z,-shift)
# # z = z.reshape(25,25).T 
# #plt.contourf(1e9*t,1e6*V,phii)
# #plt.contourf(1e9*t,1e6*V,avsin)
# #fig.suptitle(AA(prefix)+' Input Data Contour Map')
# #plt.plot(t, phi, linewidth=3.0, color='red',linestyle='--', label="$\omega_{LC}$")

# plt.plot(t, phi, linewidth=3.0, color='red',linestyle='--', label="$\omega_{LC}$")
# #loc = plticker.MultipleLocator(base=1.0) # this locator puts ticks at regular intervals
# #plt.xaxis.set_major_locator(loc)
# plt.ylabel(r'$\varphi$')
# #plt.ylabel(r'$\omega, \ MHz$')
# plt.xlabel(r'$R, \ \Omega$');
# #plt.xscale("log");
# # plt.xticks(np.arange(-180, 181, 30))
# #plt.yticks(np.arange(-2*pi, 2.1*pi, .5*pi));  # -2*pi                              
# #plt.colorbar();

# Junction characteristics
TcL = 1.4 #1.6                               # K
TcR = 0.75*TcL#*r #0.77#                     # K 
deltacL = 1.764*kB*TcL                       # J   
deltacR = 1.764*kB*TcR                       # J 
TL = r*TcL #r*TcL# 0.77                      # K
TR = 0.01*TcL                                # K                                
deltac = 1.764*kB*TcL                        # J 
GammaL = 1e-4*deltacL                        # Dynes parameter 
GammaR = 1e-4*deltacR                        # Dynes parameter

delta = lambda T, Tc, deltac: deltac*np.tanh(1.74*abs(Tc/T-1)**0.5)
#delta1 = lambda T, Tc, deltac: deltac*np.tanh(b*(a*(Tc/T-1))**0.5)
deltaL = delta(TL, TcL, deltacL)
deltaR = delta(TR, TcR, deltacR) #0.75*deltaL# r*deltaL#
#print(GammaL)

#Vp = abs(deltaL-deltaR)/e     # V 
muL = 0*V#*deltac/e                    # J
muR = e*V#*deltac/e                    # J

f = lambda x: 1./(1. + np.exp(x))

# Density of states
#N = lambda x, y, t: abs(((x+1j*y)/((x+1j*y)**2-t**2)**0.5).real) 
N = lambda x, y, t: -(((x+1j*y)/(t**2-(x+1j*y)**2)**0.5).imag)
P = lambda x, y, t: -(((x+1j*y)/(t**2-(x+1j*y)**2)**0.5).real)

# Anomalous Gree function: Imaginary part
def M(x, y, t):
  Z = x+1j*y;  
  return (t/(t**2-Z**2)**0.5).imag#*np.sign(x)
# Anomalous Gree function: Real part
def F(x, y, t):
  Z = x+1j*y;  
  return (t/(t**2-Z**2)**0.5).real#*np.sign(x)

# dimensionless integrands for kinetic integrals
# expressed with reduced variable z = E/eV 
def dQqp(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): #np.heaviside(muL,0)*
     return (x-muL/deltac)*N(x-muL/deltac, GammaL/deltac, deltaL/deltac) * np.heaviside(muR,0)* N(x-muR/deltac, GammaR/deltac, deltaR/deltac)*(f((x-muL/deltac)*deltac/(kB*TL))-f((x-muR/deltac)*deltac/(kB*TR)))

# dimensionless integrands for kinetic integrals 
# expressed with reduced variable x=E/deltac
def dQint(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): #np.heaviside(muL,0)*
    return (x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*M(x-muR/deltac, GammaR/deltac, deltaR/deltac)*(f((x-muL/deltac)*deltac/(kB*TL))-f((x-muR/deltac)*deltac/(kB*TR)))

# dimensionless integrands for kinetic integrals
# expressed with reduced variable x=E/deltac
def dQj1(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac):
    return (x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))#+ImF(x-muL/deltac, GammaL/deltac, deltaL/deltac) * ReF(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muR/deltac)*deltac/(2*kB*TR)))
def dQj2(x, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac): #L
    return (x-muL/deltac)*F(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*M(x-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muR/deltac)*deltac/(2*kB*TR))

def dQ1re(t1, x, y, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac, Omega, V0, hbar,t):
  return scipy.real((x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(y-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))*1j*np.exp(-1j*V0/Omega*(- np.cos(Omega*t)-np.cos(Omega*(t+t1))))*np.exp(-1j/hbar*(x-muL/deltac+y-muR/deltac)*t1))
def dQ1im(x, y, t1, GammaL, GammaR, deltaL, deltaR, TL, muL, TR, muR, deltac, Omega, V0, hbar, t):
  return scipy.imag((x-muL/deltac)*M(x-muL/deltac, GammaL/deltac, deltaL/deltac)*np.heaviside(muR,0)*F(y-muR/deltac, GammaR/deltac, deltaR/deltac)*np.tanh((x-muL/deltac)*deltac/(2*kB*TL))*1j*np.exp(-1j*V0/Omega*(- np.cos(Omega*t)-np.cos(Omega*(t+t1))))*np.exp(-1j/hbar*(x-muL/deltac+y-muR/deltac)*t1))

# #Integration
# Q1re = np.zeros((np.size(r),np.size(V))) #V t
# for i in range(np.size(r)): # delta T -- x; V -- y
#   for j in range(np.size(V)): 
#     Q1[i,j] = integrate.tplquad(dQ1re, -5, 5, lambda x: -5, lambda x: 5, lambda x, y: -inf, lambda x, y: 0, args=(GammaL, GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac, Omega, V0, hbar, t[j]))[0]

# Integration
Qqp = np.zeros((np.size(r),np.size(V))) #V t
for i in range(np.size(r)): # delta T -- x; V -- y
  for j in range(np.size(V)): 
   Qqp[i,j] = integrate.quad(dQqp,-5,5,args=(GammaL, GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# rat = ['Ratio T/Tc', r]
# volt = ['Voltage (V)', V]
# hf = ['Qqp', Qqp]

#np.savetxt('param.csv', [p for p in zip(rat, volt)], delimiter=',', fmt='%s') #, fmt='%s' %1.12f

#np.savetxt('rect.csv', hf, delimiter=',', fmt='%s')

datacp = np.column_stack([r, V])
datacpfile_path = "param.txt"
np.savetxt(datacpfile_path , datacp)
datafile_path = "rect.txt"
np.savetxt(datafile_path, Qqp)

r1, V1 = np.loadtxt("param.txt", unpack=True)

Q_qp = np.loadtxt("rect.txt")   #genfrom

# Integration
Qint = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
   Qint[i,j] = integrate.quad(dQint,-5,5,args=(GammaL, GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
Qj1 = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    Qj1[i,j] = integrate.quad(dQj1,-1.05, 1.05,args=(100*GammaL, 100*GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

# Integration
Qj2 = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    Qj2[i,j] = integrate.quad(dQj2,-1.05, 1.05,args=(100*GammaL, 100*GammaR, deltaL[i], deltaR, TL[i], muL[j], TR, muR[j],deltac), points = [deltaL[i]/deltac, deltaR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

Qj = 0.5*(Qj1+Qj2)

deltaL1 = delta(TR, TcL, deltacL)
deltaR1 = delta(TL, TcR, deltacR)

# Integration
QqpR =  np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
   QqpR[i,j] = integrate.quad(dQqp,-5,5,args=(GammaL, GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac, deltaR1[i]/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
QintR = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)): 
    QintR[i,j] = integrate.quad(dQint,-5,5,args=(GammaL, GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac, deltaR1[i]/deltac], epsabs=1.49e-5,epsrel=1.49e-10)[0]

# Integration
Qj1R = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)):  
    Qj1R[i,j] = integrate.quad(dQj1,-1.05,1.05,args=(100*GammaL, 100*GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac,deltaR1[i]/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

# Integration
Qj2R = np.zeros((np.size(r),np.size(V)))
for i in range(np.size(r)):
  for j in range(np.size(V)):
    Qj2R[i,j] = integrate.quad(dQj2,-1.05,1.05,args=(100*GammaL, 100*GammaR, deltaL1, deltaR1[i], TR, muL[j], TL[i], muR[j],deltac), points = [deltaL1/deltac,deltaR1[i]/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

QjR = 0.5*(Qj1R+Qj2R)

QL = Qqp + Qj*np.sin(phi) + Qint*np.cos(phi)
QR = - QqpR + QjR*np.sin(phi) - QintR*np.cos(phi)

# Save data to files
data = np.column_stack([r, V])
datacfile_path = "param.txt"
np.savetxt(datacfile_path , datacp)
dataffile_path = "fwdhf.txt"
np.savetxt(dataffile_path, QL)
databfile_path = "bwdhf.txt"
np.savetxt(databfile_path, QR)

# plt.figure(figsize=(9,7.5))
# #plt.plot(r,(Qj11+Qj22)/2,linewidth=1.9, label= r'$I_{qp}$', color='g',linestyle='-'); #Q_{\mathrm{qp},L} 
# #plt.plot(r,(Qj[:,50]),linewidth=1.9, label= r'$I_{j}$', color='r',linestyle='-'); #Q_{\mathrm{j},L}
# #plt.plot(r,Qj,linewidth=1.9, label= r'$\dot{Q}_{j}$', color='g',linestyle='-'); #Q_{\mathrm{j},L}
# plt.plot(r,Qint[:,65]*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$\dot{Q}_{qp}$', color='b',linestyle='-'); 
# #plt.plot(r,Qqp[50,:],linewidth=1.9, label= r'$\dot{Q}_{qp}$', color='r',linestyle='-');
# #Q_{\mathrm{int},L} *GT/e**2*deltac**2*1e12
# #plt.plot(r,Qint,linewidth=1.9, label= r'$\dot{Q}_{int}$', color='r',linestyle='-'); #Q_{\mathrm{j},L}

# #plt.plot(r,(QjR-QjjR)*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$\varphi = 1 \ \pi$', color='black',linestyle='-');
# #plt.plot(r,(Qqp+Qint)*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$Q_{int,1}$', color='b',linestyle='-.');
# #plt.plot(r,-QintR*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$Q_{int,2}$', color='r',linestyle='-.');

# #plt.plot(r,-(QqpR+QintR)*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$Q_{int,1}$', color='g',linestyle='-.');

# #plt.plot(r,-(Qqp+Qj*sin(pi/2)+Qint*cos(pi/2))/(QqpR+QjR*sin(pi/2)+QintR*cos(pi/2)),linewidth=1.9, label= r'$Q_{int,1}$', color='g',linestyle='--');

# #plt.plot(r,-2*QintR*GT/e**2*deltac**2*1e12,linewidth=1.9, label= r'$Q_{int,1}$', color='g',linestyle='--');
# #plt.plot(r,-QintRr*GT/e**2*deltac**2*1e9,linewidth=1.9, label= r'$Q_{int,2}$', color='y',linestyle='--');

# #plt.ylabel(r'$\dot{Q}, \mathrm{aW} $',fontsize=24)
# plt.ylabel(r'$Q, \mathrm{pW} $',fontsize=24)
# plt.xlabel(r'$T_{L}/T_{cL}$',fontsize=24);
# #plt.xlim(0.2,0.25);
# #plt.ylim(0.,);
# plt.legend();
# #plt.savefig("crit_heat.pdf")
# #plt.savefig("batt_eff.pdf")

# QL_avg = np.trapz(QL, axis=1)  
# QR_avg = np.trapz(QR, axis=1) 

# QR_avg1 = np.trapz(QR1, axis=1) 
# # left heat fluxes
# QqpL_avg = np.trapz(Qqp, axis=1) 
# QjL_avg = np.trapz(Qj*np.sin(phi), axis=1) 
# QintL_avg = np.trapz(Qint*np.cos(phi), axis=1) 
# # right heat fluxes
# QqpR_avg = abs(np.trapz(QqpR, axis=1)) 
# QjR_avg = np.trapz(QjR*np.sin(phi), axis=1) 
# QintR_avg = abs(np.trapz(QintR*np.cos(phi), axis=1)) 

# QL_mean = np.trapz(QL, axis=0)  
# QR_mean = np.trapz(QR, axis=0) 

#QL_avg = integrade.quad(lambda x: x, phi_min, phi_max, args=(QL[i,:]), points = [deltacL/deltac, deltacR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]    
#integrate.quad(dQj1,-1.05, 1.05,args=(100*GammaL, 100*GammaR, deltacL, deltacR, 0*TL[i], muL[j], 0, muR[j],deltac),points = [deltacL/deltac, deltacR/deltac], epsabs=.2e-3, epsrel=1.4e-12)[0]

# QqpL_avg1 = np.trapz(Qqp_L, axis=1)
# QintL_avg1 = np.trapz(Qint_L*np.cos(Phi), axis=1)
# QjL_avg1 = np.trapz(Qj_L*np.sin(Phi), axis=1)
# QqpR_avg1 = np.trapz(Qqp_R, axis=1)
# QintR_avg1 = np.trapz(Qint_R*np.cos(Phi), axis=1)
# QjR_avg1 = np.trapz(Qj_R*np.sin(Phi), axis=1)#np.nonzero

#Rect = QL_avg/QR_avg
#Rect[184] = 0.5*(Rect[183]+Rect[185])